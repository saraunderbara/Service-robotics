import lejos.geom.Line;
import lejos.geom.Point;
import lejos.nxt.LCD;
import lejos.nxt.Sound;
import lejos.robotics.localization.OdometryPoseProvider;
import lejos.robotics.mapping.LineMap;


public class LCDline extends Thread{
	private static LCD lcd;
	private LineMap map;
	private Line[] list;
	private Point startPoint, endPoint;
	private MapHandler mapHandler;
	private int n;
	private OdometryPoseProvider opp;
	private int x, y, x1, y1, counter;

	public LCDline(LineMap map, MapHandler mapHandler){
		lcd = new LCD();
		this.map = map;
		this.mapHandler = mapHandler;
		list = new Line[500];
		n = 0;
		counter = 0;
		
	}

	public void draw(){
		map = mapHandler.returnMap();		//gets the map from MapHandler
		list = map.getLines();				//gets the lines from the map, as an array
		int size = list.length;
		int x1, x2, y1, y2;
		int n, x, y, m;
		double k;
		
while(list[counter]!=null){
		//if(list[counter]!=null){
			startPoint = list[counter].getP1();		//gets the start point of the line
			endPoint = list[counter].getP2();			//gets the end point of the line
			x1 = (int) startPoint.x;
			y1 = (int) startPoint.y;
			x2 = (int) endPoint.x;
			y2 = (int) endPoint.y;

			if(x2 != x1){
				n = x2 - x1;
				k = (double) (y2-y1)/ (double) (x2-x1);
				m = (int) (y1 - k * x1);
				for(int i = 0; i <= n; i++){
					x = i + x1;
					y = (int) (k * x + m);
					reCalculate(y,x);		//switch x and y to different coord
				}
			}else{
				k = m = 0;
				n = y2 - y1;
				for(int i = 0; i <= n; i++){
					x = x1;
					y = y1 + i;

					reCalculate(y,x);		//switch x and y to different coord
				}
			}
			counter++;
		}
		try {
			Thread.sleep(300);
		} catch (InterruptedException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		
	}
	
		
		/*for(int e = 0; e < size; e++){
			if(list[e] != null){
				startPoint = list[e].getP1();		//gets the start point of the line
				endPoint = list[e].getP2();			//gets the end point of the line
				x1 = (int) startPoint.x;
				y1 = (int) startPoint.y;
				x2 = (int) endPoint.x;
				y2 = (int) endPoint.y;

				if(x2 != x1){
					n = x2 - x1;
					k = (double) (y2-y1)/ (double) (x2-x1);
					m = (int) (y1 - k * x1);
					for(int i = 0; i <= n; i++){
						x = i + x1;
						y = (int) (k * x + m);
						reCalculate(y,x);		//switch x and y to different coord
					}
				}else{
					k = m = 0;
					n = y2 - y1;
					for(int i = 0; i <= n; i++){
						x = x1;
						y = y1 + i;

						reCalculate(y,x);		//switch x and y to different coord
					}
				}
			}
		}
		try {
			Thread.sleep(300);
		} catch (InterruptedException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
	}*/

	private void reCalculate(int x, int y){		//recalculate from maps coord to LCDs coord
		x = (int) ((180 - x) *  (double)100/(double)180);
		y = (int) ((90 - y) * (double)60/(double)90);
		lcd.setPixel(x,y,1);
	}
	
	public void drawRider(OdometryPoseProvider opp){
		x = (int) opp.getPose().getX();
		y = (int) opp.getPose().getY();
		reCalculate(y,x);
		try {
			Thread.sleep(300);
		} catch (InterruptedException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
	}
}

